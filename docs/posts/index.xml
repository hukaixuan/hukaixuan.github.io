<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hukx</title>
    <link>https://hukx.site/posts/</link>
    <description>Recent content in Posts on Hukx</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Hukx - All rights reserved</copyright>
    <lastBuildDate>Sat, 20 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://hukx.site/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>图解 Kubernetes 架构</title>
      <link>https://hukx.site/posts/brief-intro-to-arch-of-k8s-with-pictures/</link>
      <pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hukx.site/posts/brief-intro-to-arch-of-k8s-with-pictures/</guid>
      <description>0. 架构图 Kubernetes 组件整体架构如下图  
1. 控制面组件 1.1 kube-apiserver API server 是用于暴露 K8s API 的控制面组件，是控制面的前端端点 主要实现是 kube-apiserver。kube-apiserver 可横向扩展
1.2 etcd 一致性高可用 kv 存储，用作 K8s 集群数据的后备存储 有关 etcd 的更多信息参阅官网
1.3 kube-scheduler 用于给新创建的 Pods 分配 node 的控制面组件 影响调度策略的因素包括：局部及整体的资源需求、硬件/软件/策略 限制、亲和性及反亲和性声明、数据位置、workload 间的干扰性及 deadlines
1.4 kube-controller-manager 运行 controller 进程的控制面组件 每个 controller 逻辑上是独立的，但为了降低复杂性，他们是被编译成一个二进制文件运行在同一个进程的 这些 controller 包括：
 节点控制器（Node controller）：负责在节点发生故障时的通知和响应 副本控制器（Replication controller）：为系统中所有副本控制器对象维持正确数量的 pods 端点控制器（Endpoints controller）：填充端点（Endpoints）对象（加入 Service 与 Pod） 服务账户和令牌控制器（Service Account &amp;amp; Token controllers）：为新的命名空间创建默认账户和 API 访问 token  1.</description>
    </item>
    
    <item>
      <title>图解 Kubernetes 网络</title>
      <link>https://hukx.site/posts/brief-intro-to-networking-of-k8s-with-pictures/</link>
      <pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hukx.site/posts/brief-intro-to-networking-of-k8s-with-pictures/</guid>
      <description>Docker Networking 让我们先大致了解下 Docker Networking 默认 bridge 模式 通常 Docker 只负责当前同一 host/node 下的容器通信，不去暴露 container ip 给其他 host/node K8s 解决的问题之一就是不同 host/node 间的容器通信问题
IP in Kubernetes 下面大概介绍下 K8s 中的三大类 IP
 node IP  节点 IP，每个 K8s 节点都需要有一个 IP 地址 其实不属于 K8s 管理的范畴，通过其他方式分配，如：DHCP、手动配置、云厂商分配等   pod IP  一个 pod 里的多个 containers 共享同一个 network namespace 每个 pod 会被分配 IP 地址，通过你当前使用的 CNI(Container Network Interface) 插件的 IPAM 功能分配  最基本的方式是通过给每个 node 分配一段 IP 地址段，node 再在这个地址段中分配 IP 给其上的 pod 有些插件会动态分配 IP 段   kube-apiserver 通过启动参数 --cluster-cidr=172.</description>
    </item>
    
    <item>
      <title>Django ORM 剖析</title>
      <link>https://hukx.site/posts/description-of-django-orm/</link>
      <pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hukx.site/posts/description-of-django-orm/</guid>
      <description>ORM实现组成  Model Manager QuerySet Query SQLCompiler Database backend  DATABASE BACKENDS  基类实现及支持的数据库的各自实现（django/db/models/backends） 具体采用的是哪种实现依据数据库配置里面的ENGINE ORM的底层行为的实现 介于Django与DB driver模块之间  Databasewrapper  django.db.backends.base.BaseDatabasewrapper，其他数据库的实现继承自该类，代表一条数据库连接 实现以下内容：  connection管理、cursor管理 事务管理 定义当前数据库类型下，Django field与column type的对应映射关系，Django operators与SQL之间的映射&amp;hellip;    DatabaseOperations  django.db.backends.base.operations.BaseDatabaseOperations, 封装不同数据库的不同SQL表达 eg: mysql   oracle   sql to flushes / sequence resets  DatabaseFeatures  django.db.backends.base.features.BaseDatabaseFeatures 当前数据库支持的操作  DatabaseCreation  django.db.backends.creation.BaseDatabaseCreation Encapsulate backend-specific differences pertaining to creation and destruction of the test database.</description>
    </item>
    
    <item>
      <title>图解 Docker 虚拟化</title>
      <link>https://hukx.site/posts/docker-virtual/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hukx.site/posts/docker-virtual/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
