[{"content":"0. What is a container 容器（Containers）是基于几种 Linux 技术（如 Cgroups、Namespaces、Union filesystem）之上的抽象组合  \n1. Control groups \u0026ldquo;limits how much you can use\u0026rdquo;\n1.1 cgroups 能力  组织系统中的所有进程 负责收集资源使用信息 对资源使用进行限制或者区分优先级  1.2 Subsystems Control group 是一个抽象框架，Subsystems 是具体实现\nsubsystems 举例:  \n2. Namespaces \u0026ldquo;limits what you can see\u0026rdquo;\n2.1 Namespaces 能力  资源隔离的机制 在 namespace 内对资源的修改对当前 namespace 之外不可见 资源映射  2.2 可作 namespaces 的资源  Network Filesystem (mounts) Processes (pid) Inter-process communication (ipc) Hostname and domain name (uts) User and groups IDs cgroup  unshare\n3. Union Filesystem 3.1 copy-on-write   待补充\u0026hellip;\nRuntimes 用来管理配置 Linux 上述能力来在 host 上创建运行 containers 的软件工具  \n参考  https://youtu.be/sK5i-N34im8 Linux Container Primitives - cgroups, namespaces, and more! https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt https://tech.meituan.com/2015/03/31/cgroups.html  ","date":"2021-02-21T00:00:00Z","image":"https://hukx.site/posts/docker-virtual/2021-02-21-14-39-51_hu2ed67d350811f456e8d6a4adf4cbeca1_211969_120x120_fill_box_smart1_2.png","permalink":"https://hukx.site/posts/docker-virtual/","title":"图解 Linux Container 原理"},{"content":"0. 架构图 Kubernetes 组件整体架构如下图  \n1. 控制面组件 1.1 kube-apiserver API server 是用于暴露 K8s API 的控制面组件，是控制面的前端端点 主要实现是 kube-apiserver。kube-apiserver 可横向扩展\n1.2 etcd 一致性高可用 kv 存储，用作 K8s 集群数据的后备存储 有关 etcd 的更多信息参阅官网\n1.3 kube-scheduler 用于给新创建的 Pods 分配 node 的控制面组件 影响调度策略的因素包括：局部及整体的资源需求、硬件/软件/策略 限制、亲和性及反亲和性声明、数据位置、workload 间的干扰性及 deadlines\n1.4 kube-controller-manager 运行 controller 进程的控制面组件 每个 controller 逻辑上是独立的，但为了降低复杂性，他们是被编译成一个二进制文件运行在同一个进程的 这些 controller 包括：\n 节点控制器（Node controller）：负责在节点发生故障时的通知和响应 副本控制器（Replication controller）：为系统中所有副本控制器对象维持正确数量的 pods 端点控制器（Endpoints controller）：填充端点（Endpoints）对象（加入 Service 与 Pod） 服务账户和令牌控制器（Service Account \u0026amp; Token controllers）：为新的命名空间创建默认账户和 API 访问 token  1.5 cloud-controller-manager(可选组件) 是接入特定云的控制逻辑的控制面组件 如下列控制器包含对云平台驱动的依赖：\n 节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除 路由控制器（Route Controller）: 用于在底层云基础架构中设置路由 服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器  2. Node 组件 2.1 kubelet 运行在集群每个节点上的一个 agent，用于确保 containers 运行在 pod 中 kubelet 根据提供的 PodSpecs 确保 containers 按期望的 PodSpecs 正常地运行。它不会管理不是通过 K8s 创建的容器\n2.2 kube-proxy 运行在集群每个节点上的网络代理，实现了 K8s Service 的部分概念 kube-proxy 维护节点上的网络规则，这些规则允许从集群内部及外部与当前节点上的 Pod 的进行通信 如果操作系统有网络包过滤层且可用的话，kube-proxy 会通过它来实现网络规则，否则 kube-proxy 自身会转发流量\n2.3 Container runtime 容器运行时（the container runtime）是一个负责运行 container 的软件 K8s 支持多种容器运行时：Docker、containerd、CRI-O 及 任何 Kubernetes CRI(Container Runtime Interface)的实现\n参考  https://kubernetes.io/docs/concepts/overview/components/ https://kubernetes.io/docs/concepts/architecture/control-plane-node-communication/ https://draveness.me/understanding-kubernetes/  ","date":"2021-02-20T00:00:00Z","image":"https://hukx.site/posts/brief-intro-to-arch-of-k8s-with-pictures/2021-02-20-10-43-16_hu5d7990e807ce1f891ff764525f98dfaf_448463_120x120_fill_box_smart1_2.png","permalink":"https://hukx.site/posts/brief-intro-to-arch-of-k8s-with-pictures/","title":"图解 Kubernetes 架构"},{"content":"Docker Networking 让我们先大致了解下 Docker Networking 默认 bridge 模式 通常 Docker 只负责当前同一 host/node 下的容器通信，不去暴露 container ip 给其他 host/node K8s 解决的问题之一就是不同 host/node 间的容器通信问题\nIP in Kubernetes 下面大概介绍下 K8s 中的三大类 IP\n node IP  节点 IP，每个 K8s 节点都需要有一个 IP 地址 其实不属于 K8s 管理的范畴，通过其他方式分配，如：DHCP、手动配置、云厂商分配等   pod IP  一个 pod 里的多个 containers 共享同一个 network namespace 每个 pod 会被分配 IP 地址，通过你当前使用的 CNI(Container Network Interface) 插件的 IPAM 功能分配  最基本的方式是通过给每个 node 分配一段 IP 地址段，node 再在这个地址段中分配 IP 给其上的 pod 有些插件会动态分配 IP 段   kube-apiserver 通过启动参数 --cluster-cidr=172.16.0.0.0/16 来决定所有 pod 的 IP 地址段   service IP  K8s service 是对一组 pod 的一个抽象 所有 non-headless service 都有一个 ClusterIP kube-apiserver 通过参数 --service-cluster-ip-range=172.15.100.0/23 来决定 ClusterIPs 的 IP 池 通过 apiserver 组件管理分配，告诉 kubelet 进程 serives 与 IP 的映射关系，及 serivce 对应的 endpoints IP（如对应 pod 的 IP）    以上三者关系如图\n \nCNI Flannel Flannel 是早期的网络插件之一，适合小的 K8s 集群。运行在 OSI 网络模型的第二层数据链路层（Ethernet）\nIPAM Flannel 分配静态 IP 网段到 K8s Node，K8s Node 从分配到的网段再分配 IP 给 pod\nEncapsulation 封包 默认封包策略是 VXLAN（将 2 层以太网包封装到 UDP 包内）\nCalico Calico 运行在 OSI 网络模型的第三层网络层（IP），因此只有 IP 流量会被能被封装，and everything is routed\nIPAM Calico 使用 K8s API server 或者自己的 etcd cluster 集群来实现了动态的网段划分\nEncapsulation 封包 Calico 默认的封包策略是 “IP-in-IP”(将 3 层的 IP 包添加额外的 IP 头形成一个新的 IP 包)，开销很小，但只能封装 IP 包\n参考 Tutorial: Communication Is Key - Understanding Kubernetes Networking - Jeff Poole, Vivint Smart Home\n","date":"2021-02-19T00:00:00Z","image":"https://hukx.site/posts/brief-intro-to-networking-of-k8s-with-pictures/network_hu3d03a01dcc18bc5be0e67db3d8d209a6_41593_120x120_fill_q75_box_smart1.jpg","permalink":"https://hukx.site/posts/brief-intro-to-networking-of-k8s-with-pictures/","title":"图解 Kubernetes 网络"},{"content":"ORM实现组成  Model Manager QuerySet Query SQLCompiler Database backend  DATABASE BACKENDS  基类实现及支持的数据库的各自实现（django/db/models/backends） 具体采用的是哪种实现依据数据库配置里面的ENGINE ORM的底层行为的实现 介于Django与DB driver模块之间  Databasewrapper  django.db.backends.base.BaseDatabasewrapper，其他数据库的实现继承自该类，代表一条数据库连接 实现以下内容：  connection管理、cursor管理 事务管理 定义当前数据库类型下，Django field与column type的对应映射关系，Django operators与SQL之间的映射\u0026hellip;    DatabaseOperations  django.db.backends.base.operations.BaseDatabaseOperations, 封装不同数据库的不同SQL表达 eg: mysql   oracle   sql to flushes / sequence resets  DatabaseFeatures  django.db.backends.base.features.BaseDatabaseFeatures 当前数据库支持的操作  DatabaseCreation  django.db.backends.creation.BaseDatabaseCreation Encapsulate backend-specific differences pertaining to creation and destruction of the test database.  DatabaseIntrospection  django.db.backends.introspection.BaseDatabaseIntrospection inspectdb命令的实现  DatabaseSchemaEditor  django.db.backends.base.schema.BaseDatabaseSchemaEditor 用来做migrations  DatabaseClient  django.db.backends.base.client.BaseDatabaseClient dbshell命令的实现  SQLCompiler  django.db.models.sql.compiler.SQLCompiler 将Django Query实例转化为SQL SQLInsertCompiler/SQLDeleteCompliler/SQLUpdateCompiler/SQLAggregateCompiler Query.get_compiler() -\u0026gt; 调用DatabaseOperations.compiler() -\u0026gt; 通过DatabaseOperations.compiler_module找到SQLCompiler类 ==\u0026gt; 为该Query返回一个SQLCompiler实例  Query  django.db.models.sql.query 分为Query(普通ORM操作) / RawQuery(raw()) 包含与query相关的属性 包含select/tables/where/group_by/order_by/aggregates等 as_sql，生成SQL(self.get_compiler(connection=connection).as_sql()) query是一个树桩的数据结构，将他转变为SQL的过程包括遍历他的子节点，调用他们的as_sql方法，生成最终SQL  QuerySet  django.db.models.query.QuerySet Query实例的高层封装，提供用户使用的API 同时相当于一个查询到的记录集合的容器  Managers  django.db.models.manager.Manager Model.objects.xxx get_queryset()为当前model返回一个QuerySet, Model.objects.xxx \u0026ndash;\u0026gt; queryset.xxx do some custom\u0026hellip;    Models  the actual representation of the data and associated logic 一个Model类对应数据库中的一张表，model的每个field对应数据表中的一列 ModelBases: 所有model的元类  ","date":"2018-10-19T00:00:00Z","image":"https://hukx.site/posts/description-of-django-orm/orm_hudf531f8a2d258121f4004051d93f63b3_248402_120x120_fill_box_smart1_2.png","permalink":"https://hukx.site/posts/description-of-django-orm/","title":"Django ORM 剖析"}]